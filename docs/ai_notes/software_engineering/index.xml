<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on Siobhán K Cronin</title>
    <link>https://siobhankcronin.com/ai_notes/software_engineering/</link>
    <description>Recent content in Software Engineering on Siobhán K Cronin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://siobhankcronin.com/ai_notes/software_engineering/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/algorithm_design_manual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/algorithm_design_manual/</guid>
      <description>Algorithm Design Manual 1. Intro to Algo Design I love the motivation for proof of your algorithm - to confirm that the generalizability of your selected instances (the one&amp;rsquo;s you&amp;rsquo;ve tested) holds.
We then shift into Robot Tour Optimization. Getting to different paths efficiently on the path could be done with a travelling salesman, which requires some stochastic solve. I looked around at how I&amp;rsquo;d love this, and came back to neural combinatorial optimization with RL.</description>
    </item>
    
    <item>
      <title>API</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/api/</guid>
      <description>Application Program Interfaces (APIs) do a lot of heavy lifting in software engineering, and are a world unto themselves. Let&amp;rsquo;s cover the basics for interacting with an API, and then build out from there.
Designing an endpoint An endpoint is one end of a communication channel. In the case of an API call, the client may request data from a specific endpoint on a server. If we were designing that endpoint, we&amp;rsquo;d want to specify what information is required in that API call to serve the data.</description>
    </item>
    
    <item>
      <title>AWS Virtual Private Clouds (VPCs)</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/aws_vpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/aws_vpc/</guid>
      <description>Overview As J Cole Morrison puts it, we need Virtual Private Clouds (VPCs) because we need control of security, the organization of our resources, traffic between our services, and the ability to keep differing architectures separate.
Some terms we&amp;rsquo;ll need:
 Subnets: Route Tables: Network ACLs: Internet Gateway: NAT Gateway: Variable-length subnet masking (VLSM): Allows you to specify arbitrary-lenght prefixes. Classless Inter-Domain Routing (CIDR) block notation: IP addresses consiste of two groups of bits; the most significant bits are the network prefix (identifies a whole network or subnet) and the least significant set forms the host identifier (specifies a particular interface of a host on that network).</description>
    </item>
    
    <item>
      <title>Collections module in Python</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/collections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/collections/</guid>
      <description>Incredibly useful Python container datatypes.
Counter Counter is a dictionary subclass with no restrictions on keys and values.
from collections import Counter words = [&#39;apples&#39;,&#39;oranges&#39;, &#39;apples&#39;, &#39;apples&#39;] words1 = [&#39;oranges&#39;, &#39;oranges&#39;, &#39;oranges&#39;, &#39;apples&#39;]  # Return (element, count) pairs for n most common Counter(words).most_common()  # Subtract elements from another mapping w = Counter(words) w1 = Counter(words1) w.subract(w1) # subtraction, includes zero and negatives w - w1 # subtraction, only positive counts w &amp;amp; w1 # intersection w | w1 # union w + w1 # adds two counters together  # Some useful patterns c.</description>
    </item>
    
    <item>
      <title>Databases</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/databases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/databases/</guid>
      <description>I&amp;rsquo;d first like to explore the differences between software in the data ecology, and then dive deeper into key topics affecting their use.
File System (block storage)  HDFS AWS S3 Azure Blob Storage Alluxio Ceph  Key-Value Cache  Apache Ignite: Cache for Cassandra clusters Redis: OSS in-memory data structure storage, used as a database, cache, and message broker. Key-value based database system. Memcached: distributed memory cacheing system. Key-value associative array.</description>
    </item>
    
    <item>
      <title>Hashing</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/hashing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/hashing/</guid>
      <description>Hashing Hash functions map sequences of bytes to fixed length sequences. The value returned by a hash function is often called a hash, message digest, hash value, or checksum.
Underlying a hash table is a large array of length $N$, where most of the slots are empty. To resolve collisions (which happen when we go to enter a value at a particular position, and there is already a value there), we can either implement chaining (where we turn each slot into a linked list) or open addressing where we place the value in the next empty slot.</description>
    </item>
    
    <item>
      <title>K-nearest neighbors</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/k_nearest_neighbors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/k_nearest_neighbors/</guid>
      <description>Sometimes we want to perform an operation on an agent/vector/particle based on what we know about its neibhors. Here are contenders for measuring the nearness of any two points in an n-dimensional real vector space with fixed cartesian coordinates, and strategies for using these distances to calculate neighors:
Distance Euclidean As the name suggests, this is the square root of the sum of squares for each corresponding input pair of our points.</description>
    </item>
    
    <item>
      <title>Kafka &amp; Kinesis</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/kafka/</guid>
      <description>In Dunning &amp;amp; Friedman&amp;rsquo;s book Streaming Architecture, they state &amp;ldquo;a big difference between stream-based and traditional design &amp;hellip; is that messaging layer plays a much more prominent role.&amp;rdquo;
I am streaming architecture&amp;rsquo;s biggest fan. So many possibilities open up when you de-couple producers from consumers, and let your messaging layer do the heavy lifting on persisting events. To get at some of the finer points I thought it could be fun to compare the open source project Apache Kafka with AWS&amp;rsquo; pay-to-play Kinesis.</description>
    </item>
    
    <item>
      <title>Load Balancing Algorithms</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/load_balancer_algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/load_balancer_algorithms/</guid>
      <description>First of all, the load balancer has to keep track of which servers are healthy by routinely pinging them and recording if they respond. If a server fails a health check, it is removed from the viable server list, and will only be added again if it passes a later health check.
Algorithms Least Connection Method LB directs traffic to the server with the fewest active connections
Least Response Time Method LB directs traffic to the server with the fewest active connections and the lowest average response time.</description>
    </item>
    
    <item>
      <title>Networking</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/networking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/networking/</guid>
      <description>Terms  Connection: Built before data transfer (following protocol) and deconstructed after. Packet: The envelopes that carry your data (in pieces) from one point to the next. Includes header that includes source and destination, timestamps, network hops, plus the main portion which is the data being transfered (also called body, or payload). Network Interface: Software interface to your networking hardware. Local Area Network (LAN): A network or portion of network not publically accessible to the greater internet.</description>
    </item>
    
    <item>
      <title>Processor Scheduling</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/processor_scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/processor_scheduling/</guid>
      <description>I&amp;rsquo;m not sure why processor scheduling has so captured my imagination, but I think because it is so central to computing in general. It&amp;rsquo;s about deciding what happens when. It sparks an optimization bubble over my head &amp;mdash; how do we ensure the most efficient scheduling? The strategy a system employs is called a processor scheduling policy, or discipline. This discipline will aim to balance processor utilization, throughput, latency, and ensuring processes complete before their scheduled deadline.</description>
    </item>
    
    <item>
      <title>Scaling</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/scaling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/scaling/</guid>
      <description>Key ideas  Vertical scaling: Throw more power at the problem (faster processors, more cores, more RAM) Horizontal scaling: Distributed solution. Caching: Session states need to be stored on an external database or an external persisten cache, like Redis. Load balancing: How many load balancers do we need and where should they be positioned in the topoogy? Database replication: How are preparing for system failure? Database partitioning: Can we shunt requests to different branches?</description>
    </item>
    
    <item>
      <title>Stream Architecture</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/stream_architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/stream_architecture/</guid>
      <description>How can we build a persistent message queue that scales to millions of messages/second?
For example, today&amp;rsquo;s cars are equipped with a data storage device, the EDR (event data recorder), which stores all the sensor data for the vehicle. Such data could be used for routing, dashboard analytics, or mechanical operation (cruise control, lane correction, auto parking, etc). This is just one of many use cases in the IoT universe, all requiring connectivity to control centers and real-time processing of data streams.</description>
    </item>
    
  </channel>
</rss>