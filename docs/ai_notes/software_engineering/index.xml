<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on Siobhán K Cronin</title>
    <link>https://siobhankcronin.com/ai_notes/software_engineering/</link>
    <description>Recent content in Software Engineering on Siobhán K Cronin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://siobhankcronin.com/ai_notes/software_engineering/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/algorithm_design_manual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/algorithm_design_manual/</guid>
      <description>Algorithm Design Manual 1. Intro to Algo Design I love the motivation for proof of your algorithm - to confirm that the generalizability of your selected instances (the one&amp;rsquo;s you&amp;rsquo;ve tested) holds.
We then shift into Robot Tour Optimization. Getting to different paths efficiently on the path could be done with a travelling salesman, which requires some stochastic solve. I looked around at how I&amp;rsquo;d love this, and came back to neural combinatorial optimization with RL.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/hashing_with_python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/hashing_with_python/</guid>
      <description>Hashing Strings with Python Hash functions map sequences of bytes to fixed length sequences. The value returned by a hash function is often called a hash, message digest, hash value, or checksum.
MD5 binascii If you&amp;rsquo;re looking to hash a string, you&amp;rsquo;ll need to convert your string to binary.
# Convert string to binary binary_string = b&#39;abcd&#39; print(binary_string)  b&#39;abcd&#39;  # Generate hexadecimal from binary string import binascii binascii.</description>
    </item>
    
    <item>
      <title>AWS Virtual Private Clouds (VPCs)</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/aws_vpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/aws_vpc/</guid>
      <description>Overview As J Cole Morrison puts it, we need Virtual Private Clouds (VPCs) because we need control of security, the organization of our resources, traffic between our services, and the ability to keep differing architectures separate.
Some terms we&amp;rsquo;ll need: * Subnets: * Route Tables: * Network ACLs: * Internet Gateway: * NAT Gateway: * Variable-length subnet masking (VLSM): Allows you to specify arbitrary-lenght prefixes. * Classless Inter-Domain Routing (CIDR) block notation: IP addresses consiste of two groups of bits; the most significant bits are the network prefix (identifies a whole network or subnet) and the least significant set forms the host identifier (specifies a particular interface of a host on that network).</description>
    </item>
    
    <item>
      <title>Collections module in Python</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/collections_module_in_python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/collections_module_in_python/</guid>
      <description>Incredibly useful Python container datatypes.
Counter Counter is a dictionary subclass with no restrictions on keys and values.
from collections import Counter words = [&#39;apples&#39;,&#39;oranges&#39;, &#39;apples&#39;, &#39;apples&#39;] words1 = [&#39;oranges&#39;, &#39;oranges&#39;, &#39;oranges&#39;, &#39;apples&#39;]  # Return (element, count) pairs for n most common Counter(words).most_common()  # Subtract elements from another mapping w = Counter(words) w1 = Counter(words1) w.subract(w1) # subtraction, includes zero and negatives w - w1 # subtraction, only positive counts w &amp;amp; w1 # intersection w | w1 # union w + w1 # adds two counters together  # Some useful patterns c.</description>
    </item>
    
    <item>
      <title>K-nearest neighbors</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/k_nearest_neighbors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/k_nearest_neighbors/</guid>
      <description>Sometimes we want to perform an operation on an agent/vector/particle based on what we know about its neibhors. Here are contenders for measuring the nearness of any two points in an n-dimensional real vector space with fixed cartesian coordinates, and strategies for using these distances to calculate neighors:
Distance Euclidean As the name suggests, this is the square root of the sum of squares for each corresponding input pair of our points.</description>
    </item>
    
    <item>
      <title>Processor Scheduling</title>
      <link>https://siobhankcronin.com/ai_notes/software_engineering/processor_scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://siobhankcronin.com/ai_notes/software_engineering/processor_scheduling/</guid>
      <description>I&amp;rsquo;m not sure why processor scheduling has so captured my imagination, but I think because it is so central to computing in general. What happens when. It sparks an otimization bubble over my head &amp;mdash; how do we ensure the most efficient scheduling? The staregy a system employs is called a processor scheduling policy, or discipline. This discipline will aim to balance processor utilization, throughput, latency, and ensuring processes complete before their scheduled deadline.</description>
    </item>
    
  </channel>
</rss>